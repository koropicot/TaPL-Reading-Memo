#第5章 型無しラムダ計算
型システムを展開していくベースとして型無しラムダ計算を学ぶ。

##5.1 基礎
ラムダ計算とは関数定義および関数適用(のみ)からなる体系である。

###ラムダ項の定義

```
t ::=
  x       変数
  λx.t   ラムダ抽象
  t t     関数適用
```

抽象のbody`t`は可能な限り大きく取る。
関数適用は左結合。

メタ変数(変数x/項t)とラムダ項の中の変数(変数上のメタ変数xが指す対象としてのx)の区別大事。

###束縛、自由、閉じた項
`λx.t`の中のxはこの抽象で束縛されているという。
逆にどの抽象にも束縛されていない変数は自由であるという。
自由な変数を含まない項を閉じた項(コンビネータ)という。

###評価戦略
λ計算の評価とは、すなわち`(λx.s)t`なる簡約基を`(λx.s)t→s[x:=t]`とすること。
これをベータ簡約という。

λ項には簡約基が複数含まれうる。
評価時にどの簡約基を簡約するかを評価戦略と言い、評価戦略によりその計算の意味論は異なってくる。
Haskellで有名な遅延評価(必要呼び)も評価戦略。

しかし型システムを考える上では(特に基本的な型システムにおいては)あまり差はない。
TaPLでは値呼びを用いる。

##5.2 ラムダ計算でのプログラミング
ラムダ計算でのいくつかの概念のプログラミングに触れ、慣れる。

###ラムダ計算での諸要素の表現
複数引数はカリー化。
構造を持った値はチャーチエンコーディング。
再帰は不動点コンビネータ。

###拡張
ラムダ計算に3章のNBを追加した体系では、チャーチエンコーディングの値と
プリミティブな値を相互に変換できる。
チャーチエンコーディングでは、(評価戦略により)同じ値を表現する正規形が複数存在しうる。
プリミティブな値にすることで唯一の項を得られる。

##5.3 形式的議論

###自由変数
ある項の自由変数の集合を得る関数FVは以下のように定義される。

```
FV(x) = {x}
FV(λx.t) = FV(t) - {x}
FV(t1 t2) = FV(t1)∪FV(t2)
```

###代入
代入は単純には

```
[x↦s]x = s
[x↦s]y = y (x≠y)
[x↦s](λy.t) =  λy.[x↦s]t
[x↦s](t1 t2) = ([x↦s]t1)([x↦s]t2)
```

であるが、このままではラムダ抽象において望んでいない束縛が発生しうる。
これを回避するために以下のように代入は定義される。

```
[x↦s]x = s
[x↦s]y = y    (ただしy≠x)
[x↦s](λy.t) =  λy.[x↦s]t    (ただしy≠xかつy∉FV(s))
[x↦s](t1 t2) = ([x↦s]t1)([x↦s]t2)
```

ここで、ラムダ抽象に対する代入で y≠xかつy∉FV(s) を満たさない場合にはyを別の変数w (w≠xかつw∉FV(s)かつw∉FV(t)) 置き換え (λw.[y↦w]t) これを満たすようにする。この置換えはα変換と呼ばれる。


###操作的意味論
値呼びの評価戦略での評価規則。

適用する項(左側)をまずは評価し、値になったら次は引数の項を値まで評価する(すなわち値呼び)。
引数が値になったら簡約基を評価する。
